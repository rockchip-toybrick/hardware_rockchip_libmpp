/* SPDX-License-Identifier: Apache-2.0 OR MIT */
/*
 * Copyright (c) 2025 Rockchip Electronics Co., Ltd.
 */

#ifndef __KMPP_BUFFER_H__
#define __KMPP_BUFFER_H__

#include "kmpp_allocator.h"

/*
 * KmppBuffer module has several functions:
 *
 * 1. buffer get / put / reference management / external commit / get info.
 *    this part is the basic user interface for KmppBuffer.
 *
 *    function:
 *
 *    kmpp_buffer_get
 *    kmpp_buffer_put
 *    kmpp_buffer_inc_ref
 *    kmpp_buffer_commit
 *    kmpp_buffer_info_get
 *
 * 2. user buffer working flow control abstraction.
 *    buffer should attach to certain group, and buffer mode control the buffer usage flow.
 *    this part is also a part of user interface.
 *
 *    function:
 *
 *    kmpp_buffer_group_get
 *    kmpp_buffer_group_normal_get
 *    kmpp_buffer_group_limit_get
 *    kmpp_buffer_group_put
 *    kmpp_buffer_group_limit_config
 *
 * 3. buffer allocator management
 *    this part is for allocator on different os, it does not have user interface
 *    it will support normal buffer, Android ion buffer, Linux v4l2 vb2 buffer
 *    user can only use KmppBufferType to choose.
 *
 */

/*
 * mpp buffer group support two work flow mode:
 *
 * normal flow: all buffer are generated by MPP
 *              under this mode, buffer pool is maintained internally
 *
 *              typical call flow:
 *
 *              kmpp_buffer_group_get()          return A
 *              kmpp_buffer_get(A)               return a    ref +1 -> used
 *              kmpp_buffer_inc_ref(a)                       ref +1
 *              kmpp_buffer_put(a)                           ref -1
 *              kmpp_buffer_put(a)                           ref -1 -> unused
 *              kmpp_buffer_group_put(A)
 *
 * commit flow: all buffer are commited out of MPP
 *              under this mode, buffers is commit by external api.
 *              normally MPP only use it but not generate it.
 *
 *              typical call flow:
 *
 *              ==== external allocator ====
 *              kmpp_buffer_group_get()          return A
 *              kmpp_buffer_commit(A, x)
 *              kmpp_buffer_commit(A, y)
 *
 *              ======= internal user ======
 *              kmpp_buffer_get(A)               return a
 *              kmpp_buffer_get(A)               return b
 *              kmpp_buffer_put(a)
 *              kmpp_buffer_put(b)
 *
 *              ==== external allocator ====
 *              kmpp_buffer_group_put(A)
 *
 *              NOTE: commit interface required group handle to record group information
 */

/*
 * mpp buffer group has two buffer limit mode: normal and limit
 *
 * normal mode: allows any buffer size and always general new buffer is no unused buffer
 *              is available.
 *              This mode normally use with normal flow and is used for table / stream buffer
 *
 * limit mode : restrict the buffer's size and count in the buffer group. if try to calloc
 *              buffer with different size or extra count it will fail.
 *              This mode normally use with commit flow and is used for frame buffer
 */

/*
 * NOTE: normal mode is recommanded to work with normal flow, working with limit  mode is not.
 *       limit  mode is recommanded to work with commit flow, working with normal mode is not.
 */
typedef enum {
    KMPP_BUFFER_INTERNAL,
    KMPP_BUFFER_EXTERNAL,
    KMPP_BUFFER_MODE_BUTT,
} KmppBufferMode;

/*
 * buffer group and buffer userspace transaction objects
 */
typedef enum KmppBufCmd_e {
    KMPP_BUF_GRP_CMD_BASE               = 0x0,
    KMPP_BUF_GRP_GET                    = (KMPP_BUF_GRP_CMD_BASE + 0),
    KMPP_BUF_GRP_PUT                    = (KMPP_BUF_GRP_CMD_BASE + 1),
    KMPP_BUF_GRP_RESET                  = (KMPP_BUF_GRP_CMD_BASE + 2),
    KMPP_BUF_GRP_DUMP                   = (KMPP_BUF_GRP_CMD_BASE + 3),
    KMPP_BUF_GRP_GET_USED               = (KMPP_BUF_GRP_CMD_BASE + 4),
    KMPP_BUF_GRP_GET_UNUSED             = (KMPP_BUF_GRP_CMD_BASE + 5),

    KMPP_BUF_CMD_BASE                   = 0x100,
    KMPP_BUF_GET                        = (KMPP_BUF_CMD_BASE + 0),
    KMPP_BUF_PUT                        = (KMPP_BUF_CMD_BASE + 1),
    KMPP_BUF_INC_REF                    = (KMPP_BUF_CMD_BASE + 2),
    KMPP_BUF_GET_IOVA                   = (KMPP_BUF_CMD_BASE + 4),
    KMPP_BUF_PUT_IOVA                   = (KMPP_BUF_CMD_BASE + 5),
    KMPP_BUF_FLUSH_FOR_CPU              = (KMPP_BUF_CMD_BASE + 8),
    KMPP_BUF_FLUSH_FOR_DEVICE           = (KMPP_BUF_CMD_BASE + 9),
    KMPP_BUF_FLUSH_FOR_CPU_PARTIAL      = (KMPP_BUF_CMD_BASE + 10),
    KMPP_BUF_FLUSH_FOR_DEVICE_PARTIAL   = (KMPP_BUF_CMD_BASE + 11),
} KmppBufCmd;

/* flag define is the same to the kmpp dmaheap flags */
#define KMPP_BUFGRP_FLAGS_DEFAULT       0x0000
#define KMPP_BUFGRP_FLAGS_DMA32         0x0001
#define KMPP_BUFGRP_FLAGS_CACHABLE      0x0002
#define KMPP_BUFGRP_FLAGS_CONTIG        0x0004
#define KMPP_BUFGRP_FLAGS_SECURE        0x0008
#define KMPP_BUFGRP_FLAGS_MASK          ( KMPP_BUFGRP_FLAGS_DMA32 \
                                        | KMPP_BUFGRP_FLAGS_CACHABLE \
                                        | KMPP_BUFGRP_FLAGS_CONTIG \
                                        | KMPP_BUFGRP_FLAGS_SECURE)

// vmap and mmap double size for ring buffer
#define KMPP_BUFFER_FLAGS_DUP_MAP       0x0001
#define KMPP_BUFFER_FLAGS_MASK          (KMPP_BUFFER_FLAGS_DUP_MAP)

typedef void* KmppBufGrpCfg;
typedef void* KmppBufCfg;

/*
 * KmppBuffer function usage
 * 1. get buffer group by kmpp_buf_grp_get / kmpp_buf_grp_get_share
 * 2. get buffer group config by kmpp_buf_grp_get_cfg
 * 3. setup buffer group config entry by kmpp_buf_grp_cfg_set_xxx
 *    config size limit, count limit, flag, mode and allocator etc.
 * 4. enable buffer group config by kmpp_buf_grp_setup
 * 5. get buffer entry by kmpp_buffer_get
 * 6. get buffer config by kmpp_buffer_get_cfg
 * 7. setup buffer config entry by kmpp_buffer_cfg_set_xxx
 *    config group, size, mode, flag and fd etc.
 * 8. enable buffer config by kmpp_buffer_setup
 * 9. use the buffer by kmpp_buffer_get_xxx
 *    get_iova, get_dma_handle, get_fd, get_vaddr, get_paddr and so on.
 * 10. release buffer by kmpp_buffer_put
 * 11. reset buffer group by kmpp_buf_grp_reset to clear all old buffers.
 * 12. release buffer group by kmpp_buf_grp_put
 */

/* enable user group config */
rk_s32 kmpp_buf_grp_setup(KmppBufGrp group, const rk_u8 *caller);
/* discard all old buffer and prepare for new config */
rk_s32 kmpp_buf_grp_reset(KmppBufGrp group, const rk_u8 *caller);

#define KMPP_BUF_GRP_STRUCT_TABLE(ENTRY, prefix) \
    ENTRY(prefix, shm,  KmppShmPtr,     cfg)

#define KMPP_OBJ_NAME                   kmpp_buf_grp
#define KMPP_OBJ_INTF_TYPE              KmppBufGrp
#define KMPP_OBJ_STRUCT_TABLE           KMPP_BUF_GRP_STRUCT_TABLE
#include "kmpp_obj_func.h"

/* helper functions */
KmppShmPtr *kmpp_buf_grp_get_cfg_s(KmppBufGrp group);
KmppBufGrpCfg kmpp_buf_grp_get_cfg_k(KmppBufGrp group);
rk_u64 kmpp_buf_grp_get_cfg_u(KmppBufGrp group);

#define kmpp_buf_grp_setup_f(group) kmpp_buf_grp_setup(group, __FUNCTION__)
#define kmpp_buf_grp_reset_f(group) kmpp_buf_grp_reset(group, __FUNCTION__)


/*
 * flag   - the buffer group flag for dma32 / cacheable / contiguous within KMPP_BUFGRP_FLAGS_MASK
 * count  - the buffer group count limit, 0 for no limit
 * size   - the buffer group size limit, 0 for no limit
 * mode   - the buffer group mode for internal / external
 * fd     - the dmaheap device fd when allocator is invalid
 * used   - the buffer group used buffer count
 * unused - the buffer group unused buffer count
 * device - the dmabuf device when allocator is invalid
 */
#define KMPP_BUF_GRP_CFG_ENTRY_TABLE(ENTRY, prefix) \
    ENTRY(prefix, u32,  rk_u32,         flag) \
    ENTRY(prefix, u32,  rk_u32,         count) \
    ENTRY(prefix, u32,  rk_u32,         size) \
    ENTRY(prefix, s32,  rk_s32,         fd) \
    ENTRY(prefix, s32,  rk_s32,         used) \
    ENTRY(prefix, s32,  rk_s32,         unused) \
    ENTRY(prefix, u32,  KmppBufferMode, mode) \
    ENTRY(prefix, kptr, void *,         device)

/*
 * allocator - allocator name
 * name - the buffer group name
 */
#define KMPP_BUF_GRP_CFG_STRUCT_TABLE(ENTRY, prefix) \
    ENTRY(prefix, shm,  KmppShmPtr,     allocator) \
    ENTRY(prefix, shm,  KmppShmPtr,     name)

#define KMPP_OBJ_NAME                   kmpp_buf_grp_cfg
#define KMPP_OBJ_INTF_TYPE              KmppBufGrpCfg
#define KMPP_OBJ_ENTRY_TABLE            KMPP_BUF_GRP_CFG_ENTRY_TABLE
#define KMPP_OBJ_STRUCT_TABLE           KMPP_BUF_GRP_CFG_STRUCT_TABLE
#include "kmpp_obj_func.h"


rk_s32 kmpp_buffer_setup(KmppBuffer buffer, const rk_u8 *caller);
rk_s32 kmpp_buffer_inc_ref(KmppBuffer buffer, const rk_u8 *caller);

/* helper functions */
KmppShmPtr *kmpp_buffer_get_cfg_s(KmppBuffer buffer);
KmppBufCfg kmpp_buffer_get_cfg_k(KmppBuffer buffer);
rk_u64 kmpp_buffer_get_cfg_u(KmppBuffer buffer);
void *kmpp_buffer_get_kptr(KmppBuffer buffer);
rk_u32 kmpp_buffer_get_size(KmppBuffer buffer);
rk_s32 kmpp_buffer_get_fd(KmppBuffer buffer);

#define KMPP_BUFFER_STRUCT_TABLE(ENTRY, prefix) \
    ENTRY(prefix, shm,  KmppShmPtr,     cfg)

#define KMPP_OBJ_NAME                   kmpp_buffer
#define KMPP_OBJ_INTF_TYPE              KmppBuffer
#define KMPP_OBJ_STRUCT_TABLE           KMPP_BUFFER_STRUCT_TABLE
#include "kmpp_obj_func.h"

#define kmpp_buffer_setup_f(buffer) kmpp_buffer_setup(buffer, __FUNCTION__)
#define kmpp_buffer_inc_ref_f(buffer) kmpp_buffer_inc_ref(buffer, __FUNCTION__)


/*
 * KmppBufCfg is the config object to setup KmppBuffer
 * size     - the buffer size
 * offset   - the buffer offset from the buffer base
 * flag     - the buffer flag within KMPP_BUFFER_FLAGS_MASK
 * fd       - the file handle of the buffer / fd in userspace
 * index    - the buffer index used to track buffer in buffer pool
 * khnd     - the kernel handle of the buffer (mpi_buf)
 * kdmabuf  - the struct dma_buf * in kernel space
 * file     - the share buffer handle for sharing to userspace
 */
#define KMPP_BUF_CFG_ENTRY_TABLE(ENTRY, prefix) \
    ENTRY(prefix, u32,  rk_u32,         size) \
    ENTRY(prefix, u32,  rk_u32,         offset) \
    ENTRY(prefix, u32,  rk_u32,         flag) \
    ENTRY(prefix, s32,  rk_s32,         fd) \
    ENTRY(prefix, s32,  rk_s32,         index) \
    ENTRY(prefix, kptr, void *,         khnd) \
    ENTRY(prefix, kptr, void *,         kdmabuf)

#define KMPP_BUF_CFG_STRUCT_TABLE(ENTRY, prefix) \
    ENTRY(prefix, shm,  KmppShmPtr,     sptr) \
    ENTRY(prefix, shm,  KmppShmPtr,     group)

/* entry table for userspace access */
#define KMPP_BUF_CFG_ENTRY_USER_TABLE(ENTRY, prefix) \
    ENTRY(prefix, uptr, rk_u64,         uptr) \
    ENTRY(prefix, uptr, rk_u64,         upriv) \
    ENTRY(prefix, ufp,  rk_u64,         ufp)

#define KMPP_OBJ_NAME                   kmpp_buf_cfg
#define KMPP_OBJ_INTF_TYPE              KmppBufCfg
#define KMPP_OBJ_ENTRY_TABLE            KMPP_BUF_CFG_ENTRY_TABLE
#define KMPP_OBJ_STRUCT_TABLE           KMPP_BUF_CFG_STRUCT_TABLE
#include "kmpp_obj_func.h"


rk_s32 kmpp_buffer_read(KmppBuffer buffer, rk_u32 offset, void *data, rk_s32 size, const rk_u8 *caller);
rk_s32 kmpp_buffer_write(KmppBuffer buffer, rk_u32 offset, void *data, rk_s32 size, const rk_u8 *caller);

rk_s32 kmpp_buffer_get_iova(KmppBuffer buffer, rk_u64 *iova, osal_dev *dev);
rk_s32 kmpp_buffer_put_iova(KmppBuffer buffer, rk_u64 iova, osal_dev *dev);
rk_s32 kmpp_buffer_get_iova_by_device(KmppBuffer buffer, rk_u64 *iova, void *device);
rk_s32 kmpp_buffer_put_iova_by_device(KmppBuffer buffer, rk_u64 iova, void *device);

rk_s32 kmpp_buffer_flush_for_cpu(KmppBuffer buffer);
rk_s32 kmpp_buffer_flush_for_dev(KmppBuffer buffer, osal_dev *dev);
rk_s32 kmpp_buffer_flush_for_device(KmppBuffer buffer, void *device);
rk_s32 kmpp_buffer_flush_for_cpu_partial(KmppBuffer buffer, rk_u32 offset, rk_u32 size);
rk_s32 kmpp_buffer_flush_for_dev_partial(KmppBuffer buffer, osal_dev *dev, rk_u32 offset, rk_u32 size);
rk_s32 kmpp_buffer_flush_for_device_partial(KmppBuffer buffer, void *device, rk_u32 offset, rk_u32 size);

#endif /*__KMPP_BUFFER_H__*/
